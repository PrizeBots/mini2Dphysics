<style>
* { font-family: arial; }
body { width: 800px; margin: 20px auto; font-size: 14px; }
h1 { text-align: center; }
h3 {  }
div { text-align: left; border-radius: 5px; border: 2px solid #abf; padding: 0 10px 10px; margin: 10px; position: relative;  }
div div { border-color: #fab; }
div div div { border-color: #fbf; }
p { margin: 10px 0; }
span.overline { text-decoration: overline }
span.comment { color: #888; font-size: 13px; }
span.brace { font-size: 22px }
sub { font-size: 10px }
td { line-height: 16px; padding: 5px; } 
a { color: #45d; }

.shapes table {  }
.shapes td { vertical-align: top; padding: 5px 5px 5px 0; line-height: 20px; }
.shapes img { display: block; margin: 0 auto }

.collision td { padding: 10px 20px 10px 10px }

</style>

<h1>2D physics cheat sheet</h1>
<center>(Inspired by <a href="https://www.apress.com/la/book/9781484225820">this book</a> and <a href="https://gamedevelopment.tutsplus.com/series/how-to-create-a-custom-physics-engine--gamedev-12715">this tutorial</a>)

<div class=vectors>
  <h3>2D vectors</h3>
  <p>Structures containing 2 values [x, y], and representing either a point's coordinates, a force, or a normal.</p>
  <img src=vec2.png style=position:absolute;left:400px;top:80px width=250>
  <table>
  <tr><td>→ <b>length(V)</b><td> = <td>√<span class=overline>x² + y²</span>
  <tr><td>→ <b>add(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>[x<sub>1</sub> + x<sub>2</sub>, y<sub>1</sub> + y<sub>2</sub>]
  <tr><td>→ <b>sub(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>[x<sub>1</sub> - x<sub>2</sub>, y<sub>1</sub> - y<sub>2</sub>]
  <tr><td>→ <b>scale(V, n)</b><td> = <td>[x * n, y * n]
  <tr><td>→ <b>dist(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>√<span class=overline>(x<sub>2</sub> - x<sub>1</sub>)² + (y<sub>2</sub> - y<sub>1</sub>)²</span>
  <tr><td>→ <b><a href="https://en.wikipedia.org/wiki/Dot_product">dot</a>(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>x<sub>1</sub> * x<sub>2</sub> + y<sub>1</sub> * y<sub>2</sub>
  <tr><td>→ <b><a href="https://en.wikipedia.org/wiki/Cross_product">cross</a>(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>x<sub>1</sub> * y<sub>2</sub> - y<sub>1</sub> * x<sub>2</sub>
  <tr><td>→ <b>rotate(V,C,α)</b><td> = <td>[(x<sub>1</sub> - x<sub>c</sub>) * cos(α) - (y<sub>1</sub> - y<sub>c</sub>) * sin(α) + x<sub>c</sub>, (x<sub>1</sub> - x<sub>c</sub>) * sin(α) + (y<sub>1</sub> - y<sub>c</sub>) * cos(α) + y<sub>c</sub>] 
  <tr><td>→ <b>normalize(V)</b><td> = <td><span class=brace>⎰</span> length(V) = 0 → [0, 0]<br><span class=brace>⎱</span> length(V) > 0 → [x + 1 / length(V), y + 1 / length(V)]
  </table>
</div>

<div class=shapes>
  <h3>Rigid shapes</h3>
  <table>
  <tr>
  <td width=180>
    <b>Circle</b>
    <br>→ center (vec2) : c
    <br>→ angle (float) : α
    <br>→ fixed (boolean)
    <br>→ radius (float): r
    <br>→ boundRadius: br = r
  <td width=280>
    <b>Rectangle</b>
    <br>→ center (vec2) : c
    <br>→ angle (float) : α
    <br>→ fixed (boolean)
    <br>→ width (float): w
    <br>→ height (float): h
    <br>→ vertex (vec2*) : [v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>]
    <br>→ normal (vec2*): [n<sub>0</sub>, n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>]
    <br>→ boundRadius: br = dist(c, v0)
  <td>
    <b>Polygon</b>
    <br>→ center (vec2) : c
    <br>→ angle (float) : α
    <br>→ fixed (boolean)
    <br>→ vertex (vec2*) : [v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>, ...]
    <br>→ normal (vec2*): [n<sub>0</sub>, n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>, ...]
    <br>→ boundRadius: br = max dist(v<sub>n</sub>, c)
  <tr>
  <td>
    <img src=circle.png width=170>
  <td>
    <img src=rect.png width=260>
  <td>
    <img src=polygon.png width=220>
  
  </table>
</div>

<div class=collision>

  <h3>Collision information</h3>
  <p>→ depth: integer
  <br>→ normal: vec2
  <br>→ start: vec2
  <br>→ end: vec2

  <h3>Collision detection</h3>
  <p>When the scene contains two or more rigid shapes, the collisions must be tested between every pair of shapes, A and B.
  
  <div>
  <h4>I. Broad phase method</h4>
  <p>First, quickly determine if the shapes are far away from each other by testing if their bounding circles intersect:
  <br>If <b>dist(c<sub>1</sub>, c<sub>2</sub>) > br<sub>1</sub> + br<sub>2</sub></b>, the shapes don't intersect.
  <br>If the bounding circles intersect, use the narrow phase methods.

  <p>TO COMPLETE.
  
  </div>
  
  <div>
  <h4>II. Narrow phase methods</h4>
  
  <div>
  
  <h5>a. Circle vs circle</h5>
  
  <p>
  <table>
  <tr><td style="border-right: 1px solid #888">
  <b>If c<sub>A</sub> and c<sub>B</sub> are mingled:</b>
  <br>→ depth = max(r<sub>1</sub>, r<sub>2</sub>)
  <br>→ start = c<sub>A</sub>
  <br>→ end = c<sub>B</sub>
  <br>→ normal = [0, 1]
  
  <td>
  <b>If c<sub>A</sub> and c<sub>B</sub> are different:</b>
  <br>→ depth = dist(c<sub>1</sub>, c<sub>2</sub>) - (r<sub>1</sub> + r<sub>2</sub>)
  <br>→ start = c<sub>A</sub>
  <br>→ end = c<sub>B</sub>
  <br>→ normal = c<sub>B</sub> - c<sub>A</sub>
  </table>
  
  <p>TO COMPLETE.
  
  </div>
  
  <div>
  
  <h5>b. Rectangle vs rectangle</h5>
  <p>The Separating Axis Theorem is used to detect collisions between two polygons. Here's an efficient algorithm:
  
  <p>- for each face normal of A, search its "support point": the vertex of B that has the biggest "negative distance" from the current face of A.
  <p>- If a face of A has no support point, then all the points of B are in front of the face and the two shapes don't collide and the algorithm can stop here.
  <p>- the distance between a face and its support point is positive, and called "support point distance".
  <p>- The face with the smallest support point distance is the face with the least penetration.
  <p><b>collision<sub>AB</sub>:</b>
  <br>→ depth = support point distance
  <br>→ normal = normal face of A that has the smallest support point distance.
  <br>→ start: support point
  <br>→ end: support point + scale(normal, depth)
  
  <p>- Repeat this algorithm for each face of B vs each vertex of A, to obtain <b>collision<sub>BA</sub></b>
  
  <p>- Keep the collision that has the smallest depth 
  
  <p>TO COMPLETE.
  
  </div>
  
  <div>
  
  <h5>c. Rectangle vs circle</h5>
  
  <p>Each edge of the rectangle is surrounded by three areas.
  <br>- If the circle's center is in the top/left area, there's a collision if dist(c<sub>rect</sub>, top/left vertex) < r.
  <br>- If the circle's center is in the bottom/right area, there's a collision if dist(c<sub>rect</sub>, bottom/right vertex) < r.
  <br>- Else, the circle's center is in front of the face, and there's a collision if dist(c<sub>rect</sub>, face) < r.
    
  <p>TO COMPLETE.
  
  </div>
  </div>
  
  <div>
  <h4>III. Ensure the collision normal points towards the tested object.</h4>
  <p>if dot(normal, sub(c<sub>B</sub>, c<sub>A</sub>)) < 0
  <br>→ normal = normal.scale(-1)
  <br>→ start = end
  <br>→ end = start
  
  <p>TO COMPLETE.
  </div>
  
</div>