<style>
* { font-family: arial; }
body { width: 820px; margin: 20px auto; font-size: 14px; }
h1 { text-align: center; }
h3 {  }
div { text-align: left; border-radius: 5px; border: 2px solid #abf; padding: 0 10px 10px; margin: 0 0 10px; position: relative;  }
div div { border-color: #fab; }
div div div { border-color: #fbf; }
p { margin: 10px 0; }
span.overline { text-decoration: overline }
span.comment { color: #888; font-size: 13px; }
span.brace { font-size: 22px }
sub { font-size: 10px }
td { line-height: 16px; padding: 5px; } 
a { color: #45d; }
ul { padding-left: 20px }
.shapes table {  }
.shapes td { vertical-align: top; padding: 5px 5px 5px 0; line-height: 20px; }
.shapes img { display: block; margin: 0 auto }


.collision td { width: 50%; padding: 0 20px 5px 10px; vertical-align: top; line-height: 20px; }
.collision span.brace { font-size: 30px; line-height: 17px; }

</style>

<h1>2D physics cheat sheet</h1>
<center>(Inspired by <a href="https://www.apress.com/la/book/9781484225820">this book</a> and <a href="https://gamedevelopment.tutsplus.com/series/how-to-create-a-custom-physics-engine--gamedev-12715">this tutorial</a>)
<p>
<div class=vectors>
  <h3>2D vectors</h3>
  <p>Structures containing 2 values [x, y], and representing either a point's coordinates, a force, or a normal.</p>
  <img src=vec2.png style=position:absolute;left:400px;top:80px width=250>
  <table>
  <tr><td>→ <b>length(V)</b><td> = <td>√<span class=overline>x² + y²</span>
  <tr><td>→ <b>add(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>[x<sub>1</sub> + x<sub>2</sub>, y<sub>1</sub> + y<sub>2</sub>]
  <tr><td>→ <b>sub(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>[x<sub>1</sub> - x<sub>2</sub>, y<sub>1</sub> - y<sub>2</sub>]
  <tr><td>→ <b>scale(V, n)</b><td> = <td>[x * n, y * n]
  <tr><td>→ <b>dist(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>√<span class=overline>(x<sub>2</sub> - x<sub>1</sub>)² + (y<sub>2</sub> - y<sub>1</sub>)²</span>
  <tr><td>→ <b><a href="https://en.wikipedia.org/wiki/Dot_product">dot</a>(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>x<sub>1</sub> * x<sub>2</sub> + y<sub>1</sub> * y<sub>2</sub>
  <tr><td>→ <b><a href="https://en.wikipedia.org/wiki/Cross_product">cross</a>(V<sub>1</sub>, V<sub>2</sub>)</b><td> = <td>x<sub>1</sub> * y<sub>2</sub> - y<sub>1</sub> * x<sub>2</sub>
  <tr><td>→ <b>rotate(V,C,α)</b><td> = <td>[(x<sub>1</sub> - x<sub>c</sub>) * cos(α) - (y<sub>1</sub> - y<sub>c</sub>) * sin(α) + x<sub>c</sub>, (x<sub>1</sub> - x<sub>c</sub>) * sin(α) + (y<sub>1</sub> - y<sub>c</sub>) * cos(α) + y<sub>c</sub>] 
  <tr><td>→ <b>normalize(V)</b><td> = <td><span class=brace>⎰</span> length(V) = 0 → [0, 0]<br><span class=brace>⎱</span> length(V) > 0 → [x + 1 / length(V), y + 1 / length(V)]
  </table>
</div>

<div class=shapes>
  <h3>Rigid shapes</h3>
  <table>
  <tr>
  <td width=180>
    <b>Circle</b>
    <br>→ center (vec2) : c
    <br>→ angle (float) : α
    <br>→ fixed (boolean)
    <br>→ radius (float): r
    <br>→ boundRadius: br = r
  <td width=280>
    <b>Rectangle</b>
    <br>→ center (vec2) : c
    <br>→ angle (float) : α
    <br>→ fixed (boolean)
    <br>→ width (float): w
    <br>→ height (float): h
    <br>→ vertex (vec2*) : [v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>]
    <br>→ normals (vec2*): [n<sub>0</sub>, n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>]
    <br>→ boundRadius: br = dist(c, v0)
  <td>
    <b>Polygon</b>
    <br>→ center (vec2) : c
    <br>→ angle (float) : α
    <br>→ fixed (boolean)
    <br>→ vertex (vec2*) : [v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>, ...]
    <br>→ normals (vec2*): [n<sub>0</sub>, n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>, ...]
    <br>→ boundRadius: br = max dist(v<sub>n</sub>, c)
  <tr>
  <td>
    <img src=circle.png width=170>
  <td>
    <img src=rect.png width=260>
  <td>
    <img src=polygon.png width=220>
  
  </table>
</div>

<div class=collision>

  <h3>Collision information</h3>
  
  <table>
  <tr><td style="border-right:1px solid #888">
  <p>Collisions are tested between all pairs of shapes (A and B), and these variables are computed:
  <p><b>collision<sub>AtoB</sub></b>
  <br>→ depth: integer
  <br>→ normal: vec2
  <br>→ start: vec2
  <br>→ end = sum(start, scale(normal, depth)) 

  <td>
  <p>The opposite collision from B to A can be deduced easily:
  <p><b>collision<sub>BtoA</sub></b>
  <br>→ depth: collision<sub>AtoB</sub>.length
  <br>→ normal: scale(collision<sub>AtoB</sub>, -1)
  <br>→ start: collision<sub>AtoB</sub>.end
  <br>→ end: collision<sub>AtoB</sub>.start
  
  </table>
  
  <h3>Collision detection</h3>
  <div>
  <h4>I. Broad phase method</h4>
  <p>First, quickly determine if the shapes are far away by testing if their bounding circles intersect:
  
  <p>
  
  <span class=brace>⎰</span> <b>dist(c<sub>A</sub>, c<sub>B</sub>) > br<sub>A</sub> + br<sub>B</sub></b> → the shapes don't intersect.
  
  <br>
  
  <span class=brace>⎱</span> <b>dist(c<sub>A</sub>, c<sub>B</sub>) < br<sub>A</sub> + br<sub>B</sub></b> → the bounding circles intersect, use the narrow phase methods below.
  </table>
  
  </div>
  
  <div>
  <h4>II. Narrow phase methods</h4>
  
  <div>
  
  <h4>a. Circle vs circle</h4>
  
  <p>
  <table>
  <tr><td style="border-right: 1px solid #888;width:54%">
  
  <b>If c<sub>A</sub> and c<sub>B</sub> are different:</b>
  <br>→ depth = (r<sub>A</sub> + r<sub>B</sub>) - dist(c<sub>A</sub>, c<sub>B</sub>) 
  <br>→ normal = normalize(sub(c<sub>B</sub>, c<sub>A</sub>))
  <br>→ start = add(c<sub>B</sub>, normalize(scale(sub(c<sub>B</sub>, c<sub>A</sub>), -1)))
  
  <td>
  <b>If c<sub>A</sub> and c<sub>B</sub> are on the same coordinates:</b>
  <br>→ depth = max(r<sub>A</sub>, r<sub>B</sub>)
  <br>→ normal = [0,-1]
  <br>
  
  <div style="display:inline-block;border:none;vertical-align:middle;padding:0">→ start = 
  </div>
  
  <div style="display:inline-block;border:none;vertical-align:middle;padding: 5px 0">
  
  <span class=brace>⎰</span> r<sub>A</sub> > r<sub>B</sub> → c<sub>A</sub> + [0, r<sub>B</sub>]
  
  <br>
  
  <span class=brace>⎱</span> r<sub>B</sub> > r<sub>A</sub> → c<sub>B</sub> + [0, r<sub>B</sub>]
  </div>
  
  </table>
  
  </div>
  
  <div>
  
  <h4>b. Rectangle vs rectangle</h4>
  <p>The Separating Axis Theorem is used to detect collisions between two polygons. Here's an efficient algorithm:
  
  <p>For each face normal of A:
  <ul>
  <li>Search a "support point" in B (the vertex of B that has the biggest "negative distance" from the current face of A)
  <li>If a face of A has no support point, then the two shapes don't collide and the algorithm can stop here.
  <li>The (positive) distance between a face and its support point is called "support point distance", or spd.
  <p><b>tempCollision<sub>AB</sub></b>
  <br>→ depth = spd
  <br>→ normal = normal face of A that has the smallest spd
  <br>→ start: support point
  <br>→ end: support point + scale(normal, depth)
  
  <li>Repeat this algorithm for each face normal of B versus A, to obtain <b>tempCollision<sub>BtoA</sub></b>.
  
  <li>The final <b>collision<sub>AtoB / BtoA</sub></b> object is the tempCollision that has the smallest depth.
  </ul>
  
  </div>
  
  <div>
  
  <h4>c. Rectangle vs circle</h4>
  
  <ul>
  <li>Project the circle center cB on every face normal: <b>P<sub>i</sub> = dot(c<sub>B</sub> - A.vertex[i], A.normal[i])</b>.
  <li>If all P<sub>i</sub> are negative, c<sub>B</sub> is inside A, v<sub>closest</sub> is the vertex v[i] where P<sub>i</sub> is closest to 0, and collision<sub>AtoB</sub> is defined as:
  <br>→ depth = dist(v<sub>closest</sub>, c<sub>B</sub>) (?)
  <br>→ normal = c<sub>B</sub> - v<sub>closest</sub> (?)
  <br>→ start: v<sub>closest</sub> (?)
  <li>If not all P<sub>i</sub> are negative, c<sub>B</sub> is outside A, v<sub>closest</sub> is the vertex v[i] where P<sub>i</sub> is positive and closest to 0.
  <li>The i'th face of A is surrounded by 3 regions:
  <ul>
    <li>V1 = cB - v<sub>closest</sub>
    <br>V2 = A.vertex[(i<sub>closest</sub> + 1) % 4] - v<sub>closest</sub>
    <br>dot = dot(V1, V2)
    <br><b>Region 1:</b>
    <br>if dot < 0: collision if length(V1) > r<sub>B</sub> (otherwise, no collision)
    <br>→ depth = r<sub>B</sub> - length(V1)
    <br>→ normal = normalize(V1)
    <br>→ start = c<sub>B</sub> + scale(normal, -r<sub>B</sub>)
    
    <br>else:
    <br>V1 = c<sub>B</sub> - vertex[(i<sub>closest</sub> + 1) % 4]
    <br>V2 = v2.scale(-1)
    <br>dot = dot(V1, V2)
    <br><b>Region 2:</b>
    <br>if dot < 0: collision if length(V1) > r<sub>B</sub> (otherwise, no collision)
    <br>→ depth = r<sub>B</sub> - length(V1)
    <br>→ normal = normalize(V1)
    <br>→ start = c<sub>B</sub> + scale(normal, -r<sub>B</sub>)
    
    <br><b>Region 3:</b>
    <br>else:
    <br>if P<sub>closest</sub> < r<sub>C</sub>: collision (otherwise, no collision)
    <br>→ depth = r<sub>B</sub> - P<sub>closest</sub>
    <br>→ normal = A.normals[i<sub>closest</sub>]
    <br>→ start = c<sub>B</sub> + scale(normal, r<sub>B</sub>)
  
  </div>
  </div>
  
</div>