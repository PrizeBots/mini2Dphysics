<canvas id=a width=800 height=450></canvas>
<script>
c = a.getContext('2d');

// Vec2 lib
var Vec2 = (x,y) => ({x,y});
var length = v => dot(v,v)**.5;
var add = (v,w) => Vec2(v.x + w.x, v.y + w.y);
var substract = (v,w) => add(v, scale(w, -1));
var scale = (v,n) => Vec2(v.x * n, v.y * n);
var dot = (v,w) => v.x * w.x + v.y * w.y;
var cross = (v,w) => v.x * w.y - v.y * w.x;
var rotate = (v, center, angle, x = v.x - center.x, y = v.y - center.y) => Vec2(x * Math.cos(angle) - y * Math.sin(angle) + center.x, x * Math.sin(angle) + y * Math.cos(angle) + center.y);
var normalize = v => scale(v, 1 / (length(v) || 1));
var distance = (v,w) => length(substract(v,w));

// Globals
var mGravity = Vec2(0, 100);
var objects = [];

// Collision info (circle vs circle)
var collisionInfo = {};

// Collision info (rect vs any)
var collisionInfoR1 = {};
var collisionInfoR2 = {};

// Collision info helpers
var setInfo = (collision, D, N, S) => {
  collision.D = D; // depth
  collision.N = N; // normal
  collision.S = S; // start
  collision.E = add(S, scale(N, D)); // end
};

var changeDir = () => {
  collisionInfo.N = scale(collisionInfo.N, -1);
  [collisionInfo.S, collisionInfo.E] = [collisionInfo.E, collisionInfo.S];
};

var RigidShape = (center, mass, friction = .8, restitution = .2) => {
  var shape = {};
  shape.C = center; // center
  shape.I = 0; // inertia
  shape.F = friction; // friction
  shape.R = restitution; // restitution (bouncing)
  shape.V = Vec2(0, 0); // velocity (speed)
  shape.IM = mass ? 1 / mass : 0; // inverseMass (0 if immobile)
  shape.A = mass ? mGravity : Vec2(0, 0); // acceleration
  shape.AN = 0; // angle
  shape.AV = 0; // angle velocity
  shape.AA = 0; // angle acceleration
  shape.B = 0; // bounds radius
  objects.push(shape);
  return shape;
};

var updateRigidShape = shape => {
  var dt = .016;
  shape.V = add(shape.V, scale(shape.A, dt));
  shape.AV += shape.AA * dt;
  moveShape(shape, scale(shape.V, dt));
  rotateShape(shape, shape.AV * dt);
};

var boundTest = (s1, s2) => length(substract(s2.C, s1.C)) <= (s1.B + s2.B);

var Circle = (center, radius, mass, friction, restitution) => {
  var shape = RigidShape(center, mass, friction, restitution);
  shape.T = "C"; // Type = Circle
  shape.B = shape.RA = radius; // Bounding circle radius (equal to radius)
  shape.SP = Vec2(center.x, center.y + radius); // start point (for the line)
  
  // Set inertia (mass*radius^2)
  // 12 is a constant value that can be changed
  shape.I = shape.IM > 0 ? (1 / shape.IM) * (shape.RA * shape.RA) / 12 : 0;
  
  return shape;
};

var computeRectNormals = shape => {
  
  // N: normal of each face toward outside of rectangle
  // 0: Top, 1: Right, 2: Bottom, 3: Left
  shape.N[0] = normalize(substract(shape.X[1], shape.X[2]));
  shape.N[1] = normalize(substract(shape.X[2], shape.X[3]));
  shape.N[2] = normalize(substract(shape.X[3], shape.X[0]));
  shape.N[3] = normalize(substract(shape.X[0], shape.X[1]));
}

var Rectangle = (center, width, height, mass, friction, restitution) => {
  var shape = RigidShape(center, mass, friction, restitution);
  shape.T = "R"; // Type = rectangle
  shape.W = width;
  shape.H = height;
  shape.B = Math.hypot(width, height) / 2; // Bounding circle radius
  shape.X = []; // vertex array
  shape.N = []; // face normals array

  // Vertex: 0: TopLeft, 1: TopRight, 2: BottomRight, 3: BottomLeft
  shape.X[0] = Vec2(center.x - width / 2, center.y - height / 2);
  shape.X[1] = Vec2(center.x + width / 2, center.y - height / 2);
  shape.X[2] = Vec2(center.x + width / 2, center.y + height / 2);
  shape.X[3] = Vec2(center.x - width / 2, center.y + height / 2);

  computeRectNormals(shape);
  
  // Set inertia (mass*width^2+height^2)
  shape.I = shape.IM > 0 ? 1 / ((1 / shape.IM) * (shape.W * shape.W + shape.H * shape.H) / 12) : 0;
  
  return shape;
};

var moveShape = (shape, v) => {
  shape.C = add(shape.C, v);
  if(shape.T == "C"){
    shape.SP = add(shape.SP, v);
  }
  
  else if(shape.T == "R"){
    for(var i = 0; i < shape.X.length; i++){
      shape.X[i] = add(shape.X[i], v);
    }
  }
}

var drawShape = shape => {

  if(shape.T == "C"){
    c.beginPath();
    c.arc(shape.C.x, shape.C.y, shape.RA, 0, 7);
    c.moveTo(shape.SP.x, shape.SP.y);
    c.lineTo(shape.C.x, shape.C.y);
    c.closePath();
    c.stroke();
  }
  
  else if(shape.T == "R"){
    c.save();
    c.translate(shape.X[0].x, shape.X[0].y);
    c.rotate(shape.AN);
    c.strokeRect(0, 0, shape.W, shape.H);
    c.restore();
  }
};

var rotateShape = (shape, angle) => {
  shape.AN += angle;
  if(shape.T == "C"){
    shape.SP = rotate(shape.SP, shape.C, angle);
  }
  
  else if(shape.T == "R"){
    for(var i = 0; i < shape.X.length; i++){
      shape.X[i] = rotate(shape.X[i], shape.C, angle);
    }
    computeRectNormals(shape);
  }
}

var tmpSupportPoint;
var tmpSupportPointDist;

var findSupportPoint = (rect, dir, ptOnEdge) => {
  
  // the longest projected length
  var vToEdge;
  var projection;
  tmpSupportPointDist = -9999999;
  tmpSupportPoint = null;
  
  // check each vector of other object
  for(var i = 0; i < rect.X.length; i++){
    vToEdge = substract(rect.X[i], ptOnEdge);
    projection = dot(vToEdge, dir);
    
    // find the longest distance with certain edge
    // dir is -n direction, so the distance should be positive     
    if((projection > 0) && (projection > tmpSupportPointDist)){
      tmpSupportPoint = rect.X[i];
      tmpSupportPointDist = projection;
    }
  }
};

var findAxisLeastPenetration = (rect, otherRect, collisionInfo) => {
  var n;
  var supportPoint;
  var bestDistance = 999999;
  var bestIndex = null;
  var hasSupport = true;
  for(var i = 0; hasSupport && i < rect.N.length; i++){
    
    // Retrieve a face normal from A
    n = rect.N[i];

    // use -n as direction and the vertex on edge i as point on edge
    var dir = scale(n, -1);
    var ptOnEdge = rect.X[i];
    
    // find the support on B
    // the point has longest distance with edge i 
    findSupportPoint(otherRect, dir, ptOnEdge);
    hasSupport = (tmpSupportPoint !== null);
    
    // get the shortest support point depth
    if((hasSupport) && (tmpSupportPointDist < bestDistance)){
      bestDistance = tmpSupportPointDist;
      bestIndex = i;
      supportPoint = tmpSupportPoint;
    }
  }
  
  if(hasSupport){
    
    // all four directions have support point
    setInfo(collisionInfo, bestDistance, rect.N[bestIndex], add(supportPoint, scale(rect.N[bestIndex], bestDistance)));
  }
  
  return hasSupport;
};

var collidedRectCirc = (rect, otherCir, collisionInfo) => {
  var inside = true;
  var bestDistance = -99999;
  var nearestEdge = 0;
  var i, v;
  var circ2Pos, projection;
  for(i = 0; i < 4; i++){
  
    //find the nearest face for center of circle    
    circ2Pos = otherCir.C;
    v = substract(circ2Pos, rect.X[i]);
    projection = dot(v, rect.N[i]);
    if(projection > 0){
    
      //if the center of circle is outside of rectangle
      bestDistance = projection;
      nearestEdge = i;
      inside = false;
      break;
    }
    
    if(projection > bestDistance){
      bestDistance = projection;
      nearestEdge = i;
    }
  }
  var dis, normal;
  
  if(inside){
  
    // the center of circle is inside of rectangle
    setInfo(collisionInfo, otherCir.RA - bestDistance, rect.N[nearestEdge], substract(circ2Pos, scale(rect.N[nearestEdge], otherCir.RA)));
  }
  
  else{
    
    // the center of circle is outside of rectangle
    // v1 is from left vertex of face to center of circle 
    // v2 is from left vertex of face to right vertex of face
    var v1 = substract(circ2Pos, rect.X[nearestEdge]);
    var v2 = substract(rect.X[(nearestEdge + 1) % 4], rect.X[nearestEdge]);
    var dotp = dot(v1, v2);
    if(dotp < 0){
      
      // the center of circle is in corner region of X[nearestEdge]
      dis = length(v1);
      
      // compare the distance with radium to decide collision
      if(dis > otherCir.RA){
        return false;
      }

      normal = normalize(v1);
      setInfo(collisionInfo, otherCir.RA - dis, normal, add(circ2Pos, scale(normal, -otherCir.RA)));
    }
    
    else{
      
      // the center of circle is in corner region of X[nearestEdge+1]
      // v1 is from right vertex of face to center of circle 
      // v2 is from right vertex of face to left vertex of face
      v1 = substract(circ2Pos, rect.X[(nearestEdge + 1) % 4]);
      v2 = scale(v2, -1);
      dotp = dot(v1, v2); 
      if(dotp < 0){
        dis = length(v1);
        
        // compare the distance with radium to decide collision
        if(dis > otherCir.RA){
          return false;
        }
        normal = normalize(v1);
        radiusVec = scale(normal, -otherCir.RA);
        setInfo(collisionInfo, otherCir.RA - dis, normal, add(circ2Pos, radiusVec));
      }
      
      else{
        
        // the center of circle is in face region of face[nearestEdge]
        if(bestDistance < otherCir.RA){
          radiusVec = scale(rect.N[nearestEdge], otherCir.RA);
          setInfo(collisionInfo, otherCir.RA - bestDistance, rect.N[nearestEdge], substract(circ2Pos, radiusVec));
        }
        
        else{
          return false;
        }
      }
    }
  }
  return true;
};

var testCollision = (c1, c2, info) => {
  
  var status;
  
  // Circle vs circle
  if(c1.T === "C" && c2.T === "C"){
    var vFrom1to2 = substract(c2.C, c1.C);
    var rSum = c1.RA + c2.RA;
    var dist = length(vFrom1to2);
    if (dist > Math.sqrt(rSum * rSum)) {
      
      // not overlapping
      return false;
    }
    
    if (dist !== 0) {
      
      // overlapping but not same position
      var normalFrom2to1 = normalize(scale(vFrom1to2, -1));
      var radiusC2 = scale(normalFrom2to1, c2.RA);
      setInfo(collisionInfo, rSum - dist, normalize(vFrom1to2), add(c2.C, radiusC2));
    }
    
    else{
      
      // same position
      if (c1.RA > c2.RA) {
        setInfo(collisionInfo, rSum, Vec2(0, -1), add(c1.C, Vec2(0, c1.RA)));
      }
      
      else{
        setInfo(collisionInfo, rSum, Vec2(0, -1), add(c2.C, Vec2(0, c2.RA)));
      }
    }
    return true;
  }
  
  // Rect vs Rect
  else if(c1.T === "R" && c2.T === "R"){
    var status1 = false;
    var status2 = false;

    // find Axis of Separation for both rectangles
    status1 = findAxisLeastPenetration(c1, c2, collisionInfoR1);
    if(status1){
      status2 = findAxisLeastPenetration(c2, c1, collisionInfoR2);
      if(status2){
        
        // if both of rectangles are overlapping, choose the shorter normal as the normal     
        if(collisionInfoR1.D < collisionInfoR2.D){
          setInfo(collisionInfo, collisionInfoR1.D, collisionInfoR1.N, substract(collisionInfoR1.S, scale(collisionInfoR1.N, collisionInfoR1.D)));
        }
        
        else{
          setInfo(collisionInfo, collisionInfoR2.D, scale(collisionInfoR2.N, -1), collisionInfoR2.S);
        }
      }
    }
    return status1 && status2;
    
  }
  
  // Circle vs Rect
  else if(c1.T === "C" && c2.T === "R"){
    return collidedRectCirc(c2, c1, collisionInfo);
  }
  
  // Rect vs Circle
  else if(c1.T === "R" && c2.T === "C"){
    return collidedRectCirc(c1, c2, collisionInfo);
  }
  
};

var resolveCollision = (s1, s2, collisionInfo) => {
  if (s1.IM === 0 && s2.IM === 0) {
    return;
  }

  // correct positions
  var num = collisionInfo.D / (s1.IM + s2.IM) * .8; // .8 = poscorrectionrate = percentage of separation to project objects
  var correctionAmount = scale(collisionInfo.N, num);
  moveShape(s1, scale(correctionAmount, -s1.IM));
  moveShape(s2, scale(correctionAmount, s2.IM));
  var n = collisionInfo.N;

  // the direction of collisionInfo is always from s1 to s2
  // but the Mass is inversed, so start scale with s2 and end scale with s1
  var start = scale(collisionInfo.S, s2.IM / (s1.IM + s2.IM));
  var end = scale(collisionInfo.E, s1.IM / (s1.IM + s2.IM));
  var p = add(start, end);
  // r is vector from center of object to collision point
  var r1 = substract(p, s1.C);
  var r2 = substract(p, s2.C);

  // newV = V + AV cross R
  var v1 = add(s1.V, Vec2(-1 * s1.AV * r1.y, s1.AV * r1.x));
  var v2 = add(s2.V, Vec2(-1 * s2.AV * r2.y, s2.AV * r2.x));
  var relativeVelocity = substract(v2, v1);

  // Relative velocity in normal direction
  var rVelocityInNormal = dot(relativeVelocity, n);

  // if objects moving apart ignore
  if (rVelocityInNormal > 0) {
    return;
  }

  // compute and apply response impulses for each object  
  var newRestituion = Math.min(s1.R, s2.R);
  var newFriction = Math.min(s1.F, s2.F);

  //R cross N
  var R1crossN = cross(r1, n);
  var R2crossN = cross(r2, n);

  // Calc impulse scalar
  // the formula of jN can be found in http://www.myphysicslab.com/collision.html
  var jN = -(1 + newRestituion) * rVelocityInNormal;
  jN = jN / (s1.IM + s2.IM + R1crossN * R1crossN * s1.I + R2crossN * R2crossN * s2.I);

  // impulse is in direction of normal ( from s1 to s2)
  var impulse = scale(n, jN);
  // impulse = F dt = m * ?v
  // ?v = impulse / m
  s1.V = substract(s1.V, scale(impulse, s1.IM));
  s2.V = add(s2.V, scale(impulse, s2.IM));
  s1.AV -= R1crossN * jN * s1.I;
  s2.AV += R2crossN * jN * s2.I;
  var tangent = substract(relativeVelocity, scale(n, dot(relativeVelocity, n)));

  // relativeVelocity.dot(tangent) should less than 0
  tangent = scale(normalize(tangent), -1);
  var R1crossT = cross(r1, tangent);
  var R2crossT = cross(r2, tangent);
  var jT = -(1 + newRestituion) * dot(relativeVelocity, tangent) * newFriction;
  jT = jT / (s1.IM + s2.IM + R1crossT * R1crossT * s1.I + R2crossT * R2crossT * s2.I);

  // friction should less than force in normal direction
  if (jT > jN) {
    jT = jN;
  }

  // impulse is from s1 to s2 (in opposite direction of velocity)
  impulse = scale(tangent, jT);
  s1.V = substract(s1.V, scale(impulse, s1.IM));
  s2.V = add(s2.V, scale(impulse,s2.IM));
  s1.AV -= R1crossT * jT * s1.I;
  s2.AV += R2crossT * jT * s2.I;
};

// Init scene
rotateShape(Rectangle(Vec2(500, 200), 400, 20, 0, 0.3, 0), 2.8);
Rectangle(Vec2(200, 400), 400, 20, 0, 1, 0.5);
Rectangle(Vec2(100, 200), 200, 20, 0);
Rectangle(Vec2(10, 360), 20, 100, 0, 0, 1);

for(var i = 0; i < 10; i++){
  rotateShape(Circle(Vec2(Math.random() * 800, Math.random() * 450 / 2), Math.random() * 20 + 10, Math.random() * 30, Math.random(), Math.random()), Math.random() * 7);
  Rectangle(Vec2(Math.random() * 800, Math.random() * 450 / 2), Math.random() * 20 + 10, Math.random() * 20 + 10, Math.random() * 30, Math.random(), Math.random());
}

// Loop
setInterval(
  () => {
    
    // Draw
    a.width ^= 0;
    for(var i = 0; i < objects.length; i++){
      c.strokeStyle = '#888';
      drawShape(objects[i]);
    }
  
    // Compute collisions
    for(var k = 0; k < 15; k++){
      for(var i = 0; i < objects.length; i++){
        for(var j = i + 1; j < objects.length; j++){
          
          // Test bounds
          if(boundTest(objects[i], objects[j])){
            
            // Test collision
            if(testCollision(objects[i], objects[j], collisionInfo)){
              
              // Make sure the normal is always from object[i] to object[j]
              if(dot(collisionInfo.N, substract(objects[j].C, objects[i].C)) < 0){
                changeDir();
              }
              
              // Resolve collision
              resolveCollision(objects[i], objects[j], collisionInfo);
            }
          }
        }
      }
    }
  
    // Update scene
    for(i = 0; i < objects.length; i++){
      updateRigidShape(objects[i]);
    }
  },
  16
);
</script>