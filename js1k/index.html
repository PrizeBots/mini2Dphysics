<canvas id=a width=800 height=450></canvas>
<script>c = a.getContext('2d')</script>

<script>

// vars renamed
// a: -
// b: c1
// c: -
// d: c2
// e: vFrom1to2
// f: rSum
// g: dist
// h: correctionAmount
// i, j, k: -
// l: r1
// m: r2
// n: relativeVelocity
// o: rVelocityInNormal
// p: p
// q: R1crossN
// r: R2crossN
// s: jN
// t: impulse
// u: tangent
// v: R1crossT
// w: R2crossT
// x: jT

var Circle = (C, R, mass, B, M = mass ? 1 / mass : 0) => {
  objects.push({
    C, // center
    I: 0, // inertia
    V: Vec2(0, 0), // velocity (speed)
    M, // inverseMass (0 if immobile)
    A: Vec2(0, mass ? 90 : 0), // acceleration
    B, // angle
    D: 0, // angle velocity
    E: 0, // angle acceleration,
    R, // radius
    I: M ? (1 / M) * (R * R) / 12 : 0   // Inertia=mass * radius^2. 12 is a magic constant that can be changed
  });
};

// Vec2 lib
var Vec2 = (x,y) => ({x,y});
var length = v => dot(v,v)**.5;
var add = (v,w) => Vec2(v.x + w.x, v.y + w.y);
var substract = (v,w) => add(v, scale(w, -1));
var scale = (v,n) => Vec2(v.x * n, v.y * n);
var dot = (v,w) => v.x * w.x + v.y * w.y;
var cross = (v,w) => v.x * w.y - v.y * w.x;
var normalize = v => scale(v, 1 / (length(v) || 1));

// Globals
var objects = [];

// Init scene
Circle(Vec2(400, 1100), 800, 0, 0);
for(i = 99; i--; ){
  Circle(Vec2(Math.random() * 800, Math.random() * 800 - 600), Math.random() * 20 + 10, Math.random() * 20 + 10, Math.random() * 7);
}

// Loop
setInterval(

  e => {
    
    // Draw
    a.width ^= 0;
    for(i = objects.length; i--;){
      c.strokeStyle = '#888';
      c.save();
      c.beginPath();
      c.translate(objects[i].C.x, objects[i].C.y);
      c.rotate(objects[i].B);
      c.arc(0, 0, objects[i].R, 0, 7);
      c.lineTo(0, 0);
      c.stroke();
      c.restore();
    }
  
    // Compute collisions
    for(i = objects.length; i--;){
      for(j = objects.length; j-- > i;){
        for(k = 15; k--;){
        
          // Test collision
          b = objects[i];
          d = objects[j];
          e = substract(d.C, b.C);
          f = b.R + d.R;
          g = length(e);
          if(g < f){
            D = f - g, // depth
            N = normalize(e), // normal
            S = add(d.C, scale( normalize(scale(e, -1)), d.R)), // start
            E = add(S, scale(N, D)) // end
            
            // Resolve collision
            if(b.M || d.M){
              //  correct positions
              h = scale(N, D / (b.M + d.M) * .8); // .8 = poscorrectionrate = percentage of separation to project objects
              b.C = add(b.C, scale(h, -b.M));
              d.C = add(d.C, scale(h, d.M));

              //the direction of collisionInfo is always from b to d
              //but the Mass is inversed, so start scale with d and end scale with b
              p = add(scale(S, d.M / (b.M + d.M)), scale(E, b.M / (b.M + d.M)));
              //r is vector from center of object to collision point
              l = substract(p, b.C);
              m = substract(p, d.C);

              //newV = V + D cross R
              n = substract(add(d.V, Vec2(-1 * d.D * m.y, d.D * m.x)), add(b.V, Vec2(-1 * b.D * l.y, b.D * l.x)));

              // Relative velocity in normal direction
              o = dot(n, N);

              //if objects moving apart ignore
              if(o < 0){

                //R cross N
                q = cross(l, N);
                r = cross(m, N);

                // Calc t scalar
                // the formula of s can be found in http://www.myphysicslab.com/collision.html
                s = (-(1.5) * o) / (b.M + d.M + q * q * b.I + r * r * d.I);

                //t is in direction of normal ( from b to d)
                t = scale(N, s);
                // t = F dt = m * ?v
                // ?v = t / m
                b.V = substract(b.V, scale(t, b.M));
                d.V = add(d.V, scale(t, d.M));
                b.D -= q * s * b.I;
                d.D += r * s * d.I;
                u = scale(normalize(substract(n, scale(N, dot(n, N)))), -1);

                //n.dot(u) should less than 0
                v = cross(l, u);
                w = cross(m, u);
                x = -(1.5) * dot(n, u) * .5 / (b.M + d.M + v * v * b.I + w * w * d.I);

                //t is from b to d (in opposite direction of velocity)
                t = scale(u, x);
                b.V = substract(b.V, scale(t, b.M));
                d.V = add(d.V, scale(t,d.M));
                b.D -= v * x * b.I;
                d.D += w * x * d.I;
              }
            }
          }
        }
      }
      // Update scene
      objects[i].V = add(objects[i].V, scale(objects[i].A, .01));
      objects[i].C = add(objects[i].C, scale(objects[i].V, .01));
      objects[i].D += objects[i].E * .01;
      objects[i].B += objects[i].D * .01;
    }
  },
  9
);
</script>
